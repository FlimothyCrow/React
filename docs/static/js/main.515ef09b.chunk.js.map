{"version":3,"sources":["nuPoker/handEval.js","nuPoker/pokerGraphics.js","nuPoker/nu_poker.js","nuPoker/HandRanker.jsx","App.js","serviceWorker.js","index.js"],"names":["highCard","hand","card","face","_","orderBy","isFlush","grouped","map","countBy","val","key","suit","amount","orderedByAmount","undefined","isStraight","arrayOfFaces","handEval","length","counted","parseInt","faceCount","type","values","cardToFileName","cardObject","toString","toUpperCase","suitToString","char","deckMaker","faces","flatMap","cardFaceString","int","HandRanker","props","state","currentHand","deck","poker","this","push","setState","splice","indexOf","onClickFN","cardToHighlight","isMatch","onClick","className","src","graphic","alt","evaluated","hightlightCard","filter","includes","cardToImage","addToHand","dumpHand","console","log","removeFromHand","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"uPAEO,SAASA,EAASC,GAAO,IAAD,uBAC7B,YAAiBA,EAAjB,+CAAuB,CAAC,IAAfC,EAAc,QACrB,GAAkB,IAAdA,EAAKC,KAAY,OAAOD,GAFD,kFAI7B,OAAOE,IAAEC,QAAQJ,EAAM,CAAC,OAAQ,QAAS,CAAC,OAAQ,SAAS,GAQtD,SAASK,EAAQL,GACtB,IAAIM,EAAUH,IAAEI,IAAIJ,IAAEK,QAAQR,EAAM,SAAS,SAACS,EAAKC,GAAN,MAAe,CAAEC,KAAMD,EAAKE,OAAQH,MAC7EI,EAAkBV,IAAEC,QAAQE,EAAS,CAAC,UAAW,CAAC,SACtD,OAAqC,IAA9BO,EAAgB,GAAGD,OAAeC,EAAgB,GAAGF,UAAOG,EAG9D,SAASC,EAAWf,GACzB,IAAIgB,EAAeb,IAAEC,QAAQD,IAAEI,IAAIP,GAAM,SAACC,GAAD,OAAUA,EAAKC,SACxD,OAAIc,EAAa,GAAKA,EAAa,KAAO,EACjC,CAACA,EAAa,GAAIA,EAAa,IAC7BA,EAAa,GAAKA,EAAa,KAAO,GAAyB,IAApBA,EAAa,IAAgC,KAApBA,EAAa,GACnF,CAAC,GAAI,SADP,EAuBF,SAASC,EAASjB,GAAO,IAAD,IAC7B,IAAIA,GAAwB,IAAhBA,EAAKkB,OAAjB,CAGA,IAAIC,EA1CC,SAAmBnB,GACxB,IAAIM,EAAUH,IAAEI,IAAIJ,IAAEK,QAAQR,EAAM,SAAS,SAACS,EAAKC,GAAN,MAAe,CAAER,KAAMkB,SAASV,GAAME,OAAQH,MAC3F,OAAON,IAAEC,QAAQE,EAAS,CAAC,SAAU,QAAS,CAAC,OAAQ,QAwCzCe,CAAUrB,GACxB,OAA0B,IAAtBmB,EAAQ,GAAGP,QAAuC,KAAvB,UAAAO,EAAQ,UAAR,eAAYP,QAClC,CAAEU,KAAM,WAAYC,OAAQ,CAACJ,EAAQ,GAAGjB,KAAMiB,EAAQ,GAAGjB,OACjC,IAAtBiB,EAAQ,GAAGP,QAAuC,KAAvB,UAAAO,EAAQ,UAAR,eAAYP,QACzC,CAAEU,KAAM,aAAcC,OAAQ,CAACJ,EAAQ,GAAGjB,KAAMiB,EAAQ,GAAGjB,OACnC,IAAtBiB,EAAQ,GAAGP,OACb,CAAEU,KAAM,OAAQC,OAAQ,CAACJ,EAAQ,GAAGjB,OACZ,IAAtBiB,EAAQ,GAAGP,OACb,CAAEU,KAAM,QAASC,OAAQ,CAACJ,EAAQ,GAAGjB,OACb,IAAtBiB,EAAQ,GAAGP,OACb,CAAEU,KAAM,OAAQC,OAAQ,CAACJ,EAAQ,GAAGjB,OAClCG,EAAQL,IAASe,EAAWf,GAC9B,CAAEsB,KAAM,iBAAkBC,OAAQR,EAAWf,IAC3CK,EAAQL,GACV,CAAEsB,KAAM,QAASC,OAAQ,CAAClB,EAAQL,KAChCe,EAAWf,GACb,CAAEsB,KAAM,WAAYC,OAAQR,EAAWf,IAEvC,CAAEsB,KAAM,YAAaC,OAAQ,CAACxB,EAASC,GAAME,KAAMH,EAASC,GAAMW,QCrEtE,SAASa,EAAeC,GAC7B,IAAIvB,EAAOuB,EAAWvB,KAAKwB,WAU3B,MATa,OAATxB,EACFA,EAAO,IACW,MAATA,EACTA,EAAO,IACW,OAATA,EACTA,EAAO,IACW,OAATA,IACTA,EAAO,KAEFA,EAAOuB,EAAWd,KAAKgB,cAAgB,OAGzC,SAASC,EAAaC,GAC3B,MAAa,MAATA,EACK,SACW,MAATA,EACF,WACW,MAATA,EACF,QACW,MAATA,EACF,cADF,EClBF,SAASC,IACd,IAAIC,EAAQ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IAEpD,OAAO5B,IAAE6B,QADG,CAAC,IAAK,IAAK,IAAK,MACJ,SAACrB,GACvB,OAAOoB,EAAMxB,KAAI,SAACL,GAChB,MAAO,CAAEA,KAAMA,EAAMS,KAAMA,SA2C1B,SAASsB,EAAeC,GAC7B,OAAY,KAARA,EACK,OACU,KAARA,EACF,QACU,KAARA,EACF,OACU,IAARA,EACF,MAEAA,E,ICxDUC,E,YACnB,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KACDC,MAAQ,CACXC,YAAa,GACbC,KAAMC,KAJS,E,uEAQTf,GAC8B,IAAlCgB,KAAKJ,MAAMC,YAAYpB,SAG3BuB,KAAKJ,MAAMC,YAAYI,KAAKjB,GAC5BgB,KAAKE,SAAS,CAAEL,YAAaG,KAAKJ,MAAMC,iB,qCAG3BrC,GACbwC,KAAKJ,MAAMC,YAAYM,OAAOH,KAAKJ,MAAMC,YAAYO,QAAQ5C,GAAO,GACpEwC,KAAKE,SAAS,CAAEL,YAAaG,KAAKJ,MAAMC,gB,iCAIxCG,KAAKE,SAAS,CAAEL,YAAa,O,kCAGnBrC,EAAM6C,EAAWC,GAC3B,IAAIC,EAAUD,GAAmBA,EAAgBpC,OAASV,EAAKU,MAAQoC,EAAgB7C,OAASD,EAAKC,KACrG,OACE,0BAAM+C,QAAS,kBAAMH,EAAU7C,IAAOiD,UAAWF,GAAW,aAC1D,yBAAKE,UAAU,OAAOC,IAAK,gBAAkBC,EAAuBnD,GAAOoD,IAAI,U,+BAK3E,IAAD,OACHC,EAAYrC,EAASwB,KAAKJ,MAAMC,aAChCiB,OAAiBzC,EAIrB,OAHIwC,GAAgC,cAAnBA,EAAUhC,OACzBiC,EAAiB,CAAErD,KAAMoD,EAAU/B,OAAO,GAAIZ,KAAM2C,EAAU/B,OAAO,KAGrE,6BACE,+DACC,CAAC,IAAK,IAAK,IAAK,KAAKhB,KAAI,SAACI,GAAD,OACxB,6BACE,6BAAMyC,EAAqBzC,IAC1B,EAAK0B,MAAME,KACTiB,QAAO,SAACvD,GAAD,OAAUA,EAAKU,OAASA,KAC/BJ,KAAI,SAACN,GACJ,OAAK,EAAKoC,MAAMC,YAAYmB,SAASxD,GAG5B,0BAAMiD,UAAU,SAFhB,EAAKQ,YAAYzD,GAAM,SAACA,GAAD,OAAU,EAAK0D,UAAU1D,UAAOa,UAOxE,6BACE,2CACe,IACb,4BACEmC,QAAS,WACP,EAAKW,aAFT,gBASDC,QAAQC,IAAIrB,KAAKJ,MAAMC,aACxB,yBAAKY,UAAU,gBACZT,KAAKJ,MAAMC,YAAYpB,OAAS,GDvDtC,SAAsBlB,GAC3B,IAAIsD,EAAYrC,EAASjB,GACzB,MAAuB,SAAnBsD,EAAUhC,KACN,WAAN,OAAkBW,EAAeqB,EAAU/B,OAAO,IAAlD,KAC4B,UAAnB+B,EAAUhC,KACb,SAAN,OAAgBW,EAAeqB,EAAU/B,OAAO,IAAhD,KAC4B,aAAnB+B,EAAUhC,KACb,YAAN,OAAmBW,EAAeqB,EAAU/B,OAAO,IAAnD,gBAA8DU,EAAeqB,EAAU/B,OAAO,KAClE,SAAnB+B,EAAUhC,KACb,QAAN,OAAeW,EAAeqB,EAAU/B,OAAO,IAA/C,KAC4B,eAAnB+B,EAAUhC,KACb,cAAN,OAAqBW,EAAeqB,EAAU/B,OAAO,IAArD,gBAAgEU,EAAeqB,EAAU/B,OAAO,KACpE,UAAnB+B,EAAUhC,MAA4C,MAAxBgC,EAAU/B,OAAO,GAClD,iBACsB,UAAnB+B,EAAUhC,MAA4C,MAAxBgC,EAAU/B,OAAO,GAClD,oBACsB,UAAnB+B,EAAUhC,MAA4C,MAAxBgC,EAAU/B,OAAO,GAClD,kBACsB,UAAnB+B,EAAUhC,MAA4C,MAAxBgC,EAAU/B,OAAO,GAClD,kBACsB,aAAnB+B,EAAUhC,KACb,YAAN,OAAmBW,EAAeqB,EAAU/B,OAAO,IAAnD,oBAAkEU,EAAeqB,EAAU/B,OAAO,KACtE,mBAAnB+B,EAAUhC,KACb,kBAAN,OAAyBW,EAAeqB,EAAU/B,OAAO,IAAzD,oBAAwEU,EAAeqB,EAAU/B,OAAO,KAC5E,cAAnB+B,EAAUhC,KACb,aAAN,OAAoBW,EAAeqB,EAAU/B,OAAO,IAApD,eAA8DK,EAAaK,EAAeqB,EAAU/B,OAAO,WADtG,EC+ByCiB,CAAmBC,KAAKJ,MAAMC,cAEtE,4BACE,yBAAKY,UAAU,QACZT,KAAKJ,MAAMC,YAAY/B,KACtB,SAACN,GAAD,OAAU,EAAKyD,YAAYzD,GAAM,SAACA,GAAD,OAAU,EAAK8D,eAAe9D,KAAOsD,c,GA7E9CS,IAAMC,W,MCY/BC,MAZf,WAEE,OACE,yBAAKhB,UAAU,OACb,4BAAQA,UAAU,cACd,kBAAC,EAAD,SCEUiB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLtB,QAAQsB,MAAMA,EAAMC,a","file":"static/js/main.515ef09b.chunk.js","sourcesContent":["import _ from \"lodash\"\r\n\r\nexport function highCard(hand) {\r\n  for (var card of hand) {\r\n    if (card.face === 1) return card\r\n  }\r\n  return _.orderBy(hand, [\"face\", \"suit\"], [\"desc\", \"desc\"])[0]\r\n}\r\n\r\nexport function faceCount(hand) {\r\n  var grouped = _.map(_.countBy(hand, \"face\"), (val, key) => ({ face: parseInt(key), amount: val }))\r\n  return _.orderBy(grouped, [\"amount\", \"face\"], [\"desc\", \"asc\"])\r\n}\r\n\r\nexport function isFlush(hand) {\r\n  var grouped = _.map(_.countBy(hand, \"suit\"), (val, key) => ({ suit: key, amount: val }))\r\n  var orderedByAmount = _.orderBy(grouped, [\"amount\"], [\"desc\"])\r\n  return orderedByAmount[0].amount === 5 ? orderedByAmount[0].suit : undefined\r\n}\r\n\r\nexport function isStraight(hand) {\r\n  var arrayOfFaces = _.orderBy(_.map(hand, (card) => card.face))\r\n  if (arrayOfFaces[4] - arrayOfFaces[0] === 4) {\r\n    return [arrayOfFaces[4], arrayOfFaces[0]]\r\n  } else if (arrayOfFaces[4] - arrayOfFaces[1] === 3 && arrayOfFaces[0] === 1 && arrayOfFaces[4] === 13) {\r\n    return [14, 10]\r\n  }\r\n}\r\n\r\nexport function playerOneHigher(eval0, eval1) {\r\n  var rankedHands = {\r\n    \"high card\": 0,\r\n    pair: 1,\r\n    \"two pair\": 2,\r\n    three: 3,\r\n    straight: 4,\r\n    flush: 5,\r\n    \"full house\": 6,\r\n    four: 7,\r\n    \"straight flush\": 8,\r\n  }\r\n  var rank0 = rankedHands[eval0.type] // \"pair\"\r\n  var rank1 = rankedHands[eval1.type] // \"two pair\"\r\n  return rank0 > rank1\r\n}\r\n\r\n// ?.\r\nexport function handEval(hand) {\r\n  if (hand && hand.length === 0) {\r\n    return undefined\r\n  }\r\n  let counted = faceCount(hand)\r\n  if (counted[0].amount === 2 && counted[1]?.amount === 2) {\r\n    return { type: \"two pair\", values: [counted[1].face, counted[0].face] }\r\n  } else if (counted[0].amount === 3 && counted[1]?.amount === 2) {\r\n    return { type: \"full house\", values: [counted[0].face, counted[1].face] }\r\n  } else if (counted[0].amount === 2) {\r\n    return { type: \"pair\", values: [counted[0].face] }\r\n  } else if (counted[0].amount === 3) {\r\n    return { type: \"three\", values: [counted[0].face] }\r\n  } else if (counted[0].amount === 4) {\r\n    return { type: \"four\", values: [counted[0].face] }\r\n  } else if (isFlush(hand) && isStraight(hand)) {\r\n    return { type: \"straight flush\", values: isStraight(hand) }\r\n  } else if (isFlush(hand)) {\r\n    return { type: \"flush\", values: [isFlush(hand)] }\r\n  } else if (isStraight(hand)) {\r\n    return { type: \"straight\", values: isStraight(hand) }\r\n  } else {\r\n    return { type: \"high card\", values: [highCard(hand).face, highCard(hand).suit] }\r\n  }\r\n}\r\n","export function cardToFileName(cardObject) {\r\n  let face = cardObject.face.toString();\r\n  if (face === \"13\") {\r\n    face = \"K\";\r\n  } else if (face === \"1\") {\r\n    face = \"A\";\r\n  } else if (face === \"12\") {\r\n    face = \"Q\";\r\n  } else if (face === \"11\") {\r\n    face = \"J\";\r\n  }\r\n  return face + cardObject.suit.toUpperCase() + \".jpg\";\r\n}\r\n\r\nexport function suitToString(char) {\r\n  if (char === \"s\") {\r\n    return \"Spades\";\r\n  } else if (char === \"d\") {\r\n    return \"Diamonds\";\r\n  } else if (char === \"c\") {\r\n    return \"Clubs\";\r\n  } else if (char === \"h\") {\r\n    return \"Hearts\";\r\n  }\r\n}\r\n","import _ from \"lodash\"\r\nimport { handEval, highCard, playerOneHigher } from \"./handEval.js\"\r\nimport { suitToString } from \"./pokerGraphics\"\r\nexport function deckMaker() {\r\n  var faces = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\r\n  var suits = [\"d\", \"c\", \"s\", \"h\"]\r\n  return _.flatMap(suits, (suit) => {\r\n    return faces.map((face) => {\r\n      return { face: face, suit: suit }\r\n    })\r\n  })\r\n}\r\n\r\nexport function drawHand(deck) {\r\n  //return _.pullAt(_.shuffle(deck), _.range(5))\r\n  // to do, secret third spicy option for maintainabilito\r\n  return _.pullAt(\r\n    deck,\r\n    _.range(5).map((x) => _.random(0, deck.length))\r\n  )\r\n}\r\n\r\nexport function handToString(hand) {\r\n  var evaluated = handEval(hand)\r\n  if (evaluated.type === \"pair\") {\r\n    return `pair of ${cardFaceString(evaluated.values[0])}s`\r\n  } else if (evaluated.type === \"three\") {\r\n    return `three ${cardFaceString(evaluated.values[0])}s`\r\n  } else if (evaluated.type === \"two pair\") {\r\n    return `two pair ${cardFaceString(evaluated.values[0])} and ${cardFaceString(evaluated.values[1])}`\r\n  } else if (evaluated.type === \"four\") {\r\n    return `four ${cardFaceString(evaluated.values[0])}s`\r\n  } else if (evaluated.type === \"full house\") {\r\n    return `full house ${cardFaceString(evaluated.values[0])} and ${cardFaceString(evaluated.values[1])}`\r\n  } else if (evaluated.type === \"flush\" && evaluated.values[0] === \"c\") {\r\n    return `flush of clubs`\r\n  } else if (evaluated.type === \"flush\" && evaluated.values[0] === \"d\") {\r\n    return `flush of diamonds`\r\n  } else if (evaluated.type === \"flush\" && evaluated.values[0] === \"h\") {\r\n    return `flush of hearts`\r\n  } else if (evaluated.type === \"flush\" && evaluated.values[0] === \"s\") {\r\n    return `flush of spades`\r\n  } else if (evaluated.type === \"straight\") {\r\n    return `straight ${cardFaceString(evaluated.values[1])} through ${cardFaceString(evaluated.values[0])}`\r\n  } else if (evaluated.type === \"straight flush\") {\r\n    return `straight flush ${cardFaceString(evaluated.values[1])} through ${cardFaceString(evaluated.values[0])}`\r\n  } else if (evaluated.type === \"high card\") {\r\n    return `high card ${cardFaceString(evaluated.values[0])} of ${suitToString(cardFaceString(evaluated.values[1]))}`\r\n  }\r\n}\r\n\r\nexport function cardFaceString(int) {\r\n  if (int === 13) {\r\n    return \"King\"\r\n  } else if (int === 12) {\r\n    return \"Queen\"\r\n  } else if (int === 11) {\r\n    return \"Jack\"\r\n  } else if (int === 1) {\r\n    return \"Ace\"\r\n  } else {\r\n    return int\r\n  }\r\n}\r\n\r\nexport function isCheating(hand) {\r\n  var uniqueLength = _.uniqBy(hand, (card) => {\r\n    // return JSON.stringify(card) // to avoid deepEqual\r\n    return card.face + card.suit // to avoid deepEqual\r\n  }).length\r\n  return uniqueLength === 5 ? false : true\r\n}\r\n\r\nexport function areSuitsDesc(card0, card1) {\r\n  // implement into sortBy for multiple hands\r\n  var suitRanks = { s: 3, h: 2, d: 1, c: 0 }\r\n  return suitRanks[card0.suit] > suitRanks[card1.suit]\r\n}\r\n\r\nexport function compareHands(hands) {\r\n  var eval0 = handEval(hands[0])\r\n  var eval1 = handEval(hands[1])\r\n  var highed = _.map(hands, highCard)\r\n  var highest = Math.max.apply(\r\n    null,\r\n    highed.map((card) => card.face)\r\n  )\r\n  if (isCheating(hands[0]) === true) {\r\n    return \"player 1 disqualified\"\r\n  } else if (isCheating(hands[1]) === true) {\r\n    return \"player 2 disqualified\"\r\n  }\r\n  if (eval0.type === \"two pair\" && eval1.type === \"two pair\") {\r\n    if (eval0.values[0] === eval1.values[0]) {\r\n      return eval0.values[1] > eval1.values[1] ? hands[0] : hands[1]\r\n    } else {\r\n      return eval0.values[0] > eval1.values[0] ? hands[0] : hands[1]\r\n    }\r\n  } else if (\r\n    (eval0.type === \"pair\" && eval1.type === \"pair\") ||\r\n    (eval0.type === \"three\" && eval1.type === \"three\") ||\r\n    (eval0.type === \"four\" && eval1.type === \"four\")\r\n  ) {\r\n    return eval0.values[0] > eval1.values[0] ? hands[0] : hands[1]\r\n  } else if (highed[0].face === highed[1].face) {\r\n    return areSuitsDesc(highed[0], highed[1]) ? hands[0] : hands[1]\r\n  } else if (eval0.type === \"high card\" && eval1.type === \"high card\") {\r\n    return hands[\r\n      _.indexOf(\r\n        highed.map((card) => card.face),\r\n        highest\r\n      )\r\n    ]\r\n  } else {\r\n    return playerOneHigher(eval0, eval1) ? hands[0] : hands[1]\r\n  }\r\n}\r\n","import React from \"react\"\r\nimport * as poker from \"./nu_poker\"\r\nimport * as graphic from \"./pokerGraphics.js\"\r\nimport { handEval } from \"./handEval.js\"\r\n\r\nexport default class HandRanker extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      currentHand: [],\r\n      deck: poker.deckMaker(), //.map(cardObject => cardObject)\r\n    }\r\n  }\r\n\r\n  addToHand(cardObject) {\r\n    if (this.state.currentHand.length === 5) {\r\n      return\r\n    }\r\n    this.state.currentHand.push(cardObject)\r\n    this.setState({ currentHand: this.state.currentHand })\r\n  }\r\n\r\n  removeFromHand(card) {\r\n    this.state.currentHand.splice(this.state.currentHand.indexOf(card), 1)\r\n    this.setState({ currentHand: this.state.currentHand })\r\n  }\r\n\r\n  dumpHand() {\r\n    this.setState({ currentHand: [] })\r\n  }\r\n\r\n  cardToImage(card, onClickFN, cardToHighlight) {\r\n    let isMatch = cardToHighlight && cardToHighlight.suit === card.suit && cardToHighlight.face === card.face\r\n    return (\r\n      <span onClick={() => onClickFN(card)} className={isMatch && \"highlight\"}>\r\n        <img className=\"card\" src={\"cardGraphics/\" + graphic.cardToFileName(card)} alt=\"2C\" />\r\n      </span>\r\n    )\r\n  }\r\n\r\n  render() {\r\n    let evaluated = handEval(this.state.currentHand)\r\n    let hightlightCard = undefined\r\n    if (evaluated && evaluated.type === \"high card\") {\r\n      hightlightCard = { face: evaluated.values[0], suit: evaluated.values[1] }\r\n    }\r\n    return (\r\n      <div>\r\n        <h3>Click to select cards from deck</h3>\r\n        {[\"s\", \"d\", \"c\", \"h\"].map((suit) => (\r\n          <div>\r\n            <div>{graphic.suitToString(suit)}</div>\r\n            {this.state.deck\r\n              .filter((card) => card.suit === suit)\r\n              .map((card) => {\r\n                if (!this.state.currentHand.includes(card)) {\r\n                  return this.cardToImage(card, (card) => this.addToHand(card), undefined)\r\n                } else {\r\n                  return <span className=\"card\" />\r\n                }\r\n              })}\r\n          </div>\r\n        ))}\r\n        <div>\r\n          <h3>\r\n            Current hand{\" \"}\r\n            <button\r\n              onClick={() => {\r\n                this.dumpHand()\r\n              }}\r\n            >\r\n              Return hand\r\n            </button>\r\n          </h3>\r\n\r\n          {console.log(this.state.currentHand)}\r\n          <div className=\"handToString\">\r\n            {this.state.currentHand.length > 0 && poker.handToString(this.state.currentHand)}\r\n          </div>\r\n          <ul>\r\n            <div className=\"hand\">\r\n              {this.state.currentHand.map(\r\n                (card) => this.cardToImage(card, (card) => this.removeFromHand(card), hightlightCard) // call has to include lambda to use this.data\r\n              )}\r\n            </div>\r\n          </ul>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n// rebuild handToString to take results from handEval, not call it\r\n// highlight highest card if no other hand\r\n// multiple page > use react-router\r\n// add button to remove all cards from hand\r\n\r\n// how to publish: npm run-script build\r\n// manual copy files from /build to /docs\r\n// commit > push\r\n","import React from 'react';\nimport HandRanker from './nuPoker/HandRanker'\nimport './App.css';\n// npm start\n// npm test\nfunction App() {\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n          <HandRanker></HandRanker>\n      </header>\n      \n    </div>\n  );\n}\n\nexport default App;\n\n// notice that the calls on 15 and 16 have different syntax\n// <FizzBuzzPrinter /> for line 16\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}